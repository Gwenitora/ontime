import { LogOrigin } from 'ontime-types';

import express, { type Request, type Response, type NextFunction } from 'express';
import type { IncomingMessage } from 'node:http';
import type { WebSocket } from 'ws';
import { parse as parseCookie } from 'cookie';

import { hashPassword } from '../utils/hash.js';
import { srcFiles } from '../setup/index.js';
import { logger } from '../classes/Logger.js';
import { hashedPassword, hasSessionPassword } from '../api-data/session/session.service.js';

import { isValidHashedAlias } from '../api-data/url-presets/urlPreset.service.js';

/**
 * List of public assets that can be accessed without authentication
 * should match the files in client/public
 */
const publicAssets = new Set([
  '/favicon.ico',
  '/manifest.json',
  '/ontime-logo.png',
  '/robots.txt',
  '/site.webmanifest',
]);

export const loginRouter = express.Router();

// serve static files at root
loginRouter.use('/', express.static(srcFiles.login));

// verify password and set cookies + redirect appropriately
loginRouter.post('/', (req, res) => {
  res.clearCookie('token');
  res.clearCookie('aliastoken');
  const { password: reqPassword, redirect } = req.body;

  if (hashPassword(reqPassword) === hashedPassword) {
    setSessionCookie(res, hashedPassword);
    res.redirect(redirect || '/');
    return;
  }

  /**
   * The alias can be in several places in the redirect parameter
   *
   * 1. as a query parameter, link generated by our interface
   * ip/login?redirect=/test
   *
   * 2. as a search param, as the UI logic unwraps
   * ip/login?redirect=timer?alias=test
   *
   * @returns name of the alias or undefined
   */
  // TODO: extract and test
  function getAliasFromURL(redirectParams: string): string | undefined {
    const rp = redirectParams;
    return (
      rp
        .split('?')
        .at(1)
        ?.split('&')
        .find((s) => s.startsWith('alias='))
        ?.substring(6) ?? rp.replaceAll('/', '')
    );
  }

  const alias = getAliasFromURL(redirect);

  if (alias) {
    const hashedAliases = hashPassword(alias + reqPassword);
    if (isValidHashedAlias(hashedAliases)) {
      setAliasCookie(res, hashedAliases);
      res.redirect(redirect);
      return;
    }
  }

  res.status(401).send('Unauthorized');
});

/**
 * Factory function creates authentication middleware functions
 * @param {string} prefix - Prefix is used for the client hashes in Ontime Cloud
 */
export function makeAuthenticateMiddleware(prefix: string): {
  authenticate: (req: Request, res: Response, next: NextFunction) => void;
  authenticateAndRedirect: (req: Request, res: Response, next: NextFunction) => void;
} {
  /**
   * Used for API and data endpoints
   * Users get here with
   * - an automation or API consumer (eg companion), these should not target aliases
   * - the Ontime UI which has been previously authenticated
   *
   * 1. check if the session is password protected
   * 2. check if user has a cookie from previous sessions
   * 4. check if there is a session level token
   * 5. check if there is an authenticated alias
   */
  function authenticate(req: Request, res: Response, next: NextFunction) {
    if (!hasSessionPassword) {
      return next();
    }

    const token = req.query.token || req.cookies?.token;
    if ((token && token === hashedPassword) || isValidHashedAlias(req.cookies?.aliastoken)) {
      return next();
    }

    res.status(401).send('Unauthorized');
  }

  /**
   * Used for entrypoint of app
   * Is the first entrypoint on the user journey
   * 1. check if the session is password protected
   * 2. check if user has a cookie from previous sessions or alias token
   * 3. check if the user is requesting public assets
   * 4. check if there is a session level token
   * 5. check if there is an authenticated alias
   */
  function authenticateAndRedirect(req: Request, res: Response, next: NextFunction) {
    /**
     * 1. check if the session is password protected
     */
    if (!hasSessionPassword) {
      return next();
    }

    /**
     * 2. check if user has a cookie from previous sessions or alias token
     */
    if (req.cookies?.token === hashedPassword || isValidHashedAlias(req.cookies?.aliastoken)) {
      return next();
    }

    /**
     * 3. check if the user is requesting public assets
     * - public assets
     * - login page
     */
    if (publicAssets.has(req.originalUrl) || req.originalUrl.startsWith('/login')) {
      return next();
    }

    /**
     * 4. check if there is a session level token
     * we use query params for generating authenticated URLs and for clients like the companion module
     * if the user gives is a token in the query params, we set the cookie to be used in further requests
     */
    if (req.query.token === hashedPassword) {
      if (hashedPassword !== undefined) {
        setSessionCookie(res, hashedPassword);
      }
      return next();
    }

    /**
     * 5. check if there is an authenticated alias
     * //TODO: also do this for alias
     * there could be 2 options
     * - in a query param ?alias=my-alias&token=maybe-token - maybe we can ignore this as unpacked alias should already be authenticated
     * - in a pathname param ip/my-alias?token=maybe-token
     */

    /**
     * - the session has a password
     * - the user has no token in cookie or query params
     * redirect to login with a redirect
     */
    res.redirect(`${prefix}/login?redirect=${req.originalUrl}`);
  }

  return { authenticate, authenticateAndRedirect };
}

/**
 * Middleware to authenticate a WebSocket connection
 * 1. check if the session is password protected
 * 2. check if user has a cookie from previous sessions or alias token
 * 4. check if there is a session level token in the searchParams, this is used byt things like companion
 */
export function authenticateSocket(_ws: WebSocket, req: IncomingMessage, next: (error?: Error) => void) {
  if (!hasSessionPassword) {
    return next();
  }

  const cookieString = req.headers.cookie;

  // check if the token is in the cookie
  if (typeof cookieString === 'string') {
    const cookies = parseCookie(cookieString);

    const { token, aliastoken } = cookies;
    if (token === hashedPassword || isValidHashedAlias(aliastoken)) {
      return next();
    }
  }

  // check if token is in the params
  const url = new URL(req.url || '', `http://${req.headers.host}`);
  const token = url.searchParams.get('token');
  if (token === hashedPassword) {
    return next();
  }

  logger.warning(LogOrigin.Client, 'Unauthorized WebSocket connection attempt');
  return next(new Error('Unauthorized'));
}

function setSessionCookie(res: Response, token: string) {
  res.cookie('token', token, {
    httpOnly: false, // allow websocket to access cookie
    secure: true,
    path: '/', // allow cookie to be accessed from any path
    sameSite: 'none', // allow cookies to be sent in cross-origin requests (e.g., iframes)
  });
}

function setAliasCookie(res: Response, alias: string) {
  res.cookie('aliastoken', alias, {
    httpOnly: false, // allow websocket to access cookie
    secure: true,
    path: '/', // allow cookie to be accessed from any path
    sameSite: 'none', // allow cookies to be sent in cross-origin requests (e.g., iframes)
  });
}
